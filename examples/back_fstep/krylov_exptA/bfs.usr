c-----------------------------------------------------------------------
      subroutine userchk
      use neklab
      !use LightKrylov_Logger
      include 'SIZE'
      include 'TOTAL'

      type(nek_dvector) :: bf
    	type(exptA_linop) :: exptA
      type(LNS_linop)   :: A
      type(DTD_linop)   :: DTD
      real(dp) :: tau, rnorm

      type(nek_pr_dvector) :: dpr, xCG
      real(dp), dimension(lx2, ly2, lz2, lelv) :: ptmp
      type(cg_dp_opts) :: opts
      type(cg_dp_metadata) :: meta
      integer :: info, i

      integer, parameter :: lv = lx1*ly1*lz1*lelv
      !! Local number of grid points for the velocity mesh.
      integer, parameter :: lp = lx2*ly2*lz2*lelv
      !! Local number of grid points for the pressure mesh.

      real(dp), dimension(lv, 1) :: Lux, Luy, Luz, utmpx, utmpy, utmpz, resv1, resv2, resv3, dv1, dv2, dv3
      real(dp), dimension(lp, 1) :: pref
      !common /scrns/ resv1, resv2, resv3, dv1, dv2, dv3
      !common /scrvh/ h1, h2

      ! elements of the linearized operator (for debugging)
      real convx  (lx1*ly1*lz1*lelv,lpert)      ! convective term
     $ ,   convy  (lx1*ly1*lz1*lelv,lpert)
     $ ,   convz  (lx1*ly1*lz1*lelv,lpert)
     $ ,   gradpx (lx1*ly1*lz1*lelv,lpert)      ! pressure gradient term
     $ ,   gradpy (lx1*ly1*lz1*lelv,lpert)
     $ ,   gradpz (lx1*ly1*lz1*lelv,lpert)
     $ ,   diffx  (lx1*ly1*lz1*lelv,lpert)      ! diffusion term
     $ ,   diffy  (lx1*ly1*lz1*lelv,lpert)
     $ ,   diffz  (lx1*ly1*lz1*lelv,lpert)
!
      common /OTD_Lup/ convx,convy,convz
     $ ,               gradpx,gradpy,gradpz
     $ ,               diffx,diffy,diffz
	
    	if (istep.eq.0) then
    		! Load baseflow.
    		call load_fld("BF_bfs0.f00001")
    		call nek2vec(bf, vx, vy, vz, pr, t)

            call opcopy(vxp, vyp, vzp, vx, vy, vz)
            time = 0.0_dp

            !tau = 0.0001_dp

    		! Exponential propagator.
    		!exptA = exptA_linop(tau, bf)
            !call exptA%init()
            !ifield = 1
            !! Set up logging
            !call logger_setup(nio=0, log_level=information_level, log_stdout=.false., log_timestamp=.true.)
            !call outpost(vxp, vyp, vzp, prp, tp, 'ppp')
            !! Apply LNS (velocity part)
            !call apply_L(vxp, vyp, vzp, trans=.false.)
            !! compute divergence
            !call opdiv(prp, vxp, vyp, vzp)
            !call outpost(vxp, vyp, vzp, prp, tp, 'ppp')
            !! copy divergence field into nek_pdvector
            !call nek2pvec(dpr, prp)
            !! compute norm to see where we are at
            !if (nid.eq.0) print *, 'rnorm =', dpr%norm()
            !! DTD
            !DTD = DTD_linop()
            !call xCG%zero()
            !opts = cg_dp_opts(maxiter = 100, if_print_metadata = .true.)
            !meta = cg_dp_metadata()
            !call cg(DTD, dpr, xCG, info, rtol=rtol_dp, atol=atol_dp, options=opts, meta=meta)
            !if (nid.eq.0) call meta%print()
            !STOP 9
      end if

      if (istep == 1) then

            call opcopy(resv1, resv2, resv3, vxp, vyp, vzp)
            call copy(pref, prp, lp)

            call outpost(vxp, vyp, vzp, prp, tp, 'ref')
         !
         ! OTD
         !
            call bcdirvc(vxp, vyp, vzp,v1mask,v2mask,v3mask)
         ! Convective terms 
            call Lu_op_conv(vxp,vyp,vzp,1)
            call outpost(convx, convy, convz, prp, tp, 'cnv')

      ! Perturbation pressure gradient
            call Lu_op_gradp(prp,1)
            call outpost(gradpx, gradpy, gradpz, prp, tp, 'pgr')
         
      ! Diffusive term
            call Lu_op_diff(vxp,vyp,vzp,1)
            call outpost(diffx, diffy, diffz, prp, tp, 'dif')

            do i = 1, lv
               vxp(i, 1) = diffx(i, 1) - gradpx(i, 1) - convx(i, 1)
               vyp(i, 1) = diffy(i, 1) - gradpy(i, 1) - convy(i, 1)
               if (if3D) vzp(i, 1) = diffz(i, 1) - gradpz(i, 1) - convz(i, 1)
            end do

            call outpost(vxp, vyp, vzp, prp, tp, 'Ax_')

            call opcopy(vxp, vyp, vzp, resv1, resv2, resv3)
            call copy(prp, pref, lp)

            call outpost(vxp, vyp, vzp, prp, tp, 'ref')

            ifield = 1
            ! apply BCs
            call bcdirvc(vxp, vyp, vzp,v1mask,v2mask,v3mask)
            
            ! Diffusion term
            call compute_LNS_laplacian(Lux,Luy,Luz,vxp, vyp, vzp)
            call outpost(Lux,Luy,Luz, prp, tp, 'dif')

            ! Pressure gradient
            call compute_LNS_gradp(utmpx,utmpy,utmpz,prp)
            call outpost(utmpx,utmpy,utmpz, prp, tp, 'pgr')
            call opgradt(utmpx, utmpy, utmpz, prp)
            call outpost(utmpx,utmpy,utmpz, prp, tp, 'pgr')

            ! subtract from output terms
            call opsub2(Lux,Luy,Luz,utmpx,utmpy,utmpz)

            ! Convective terms
            call compute_LNS_conv(utmpx,utmpy,utmpz,vxp, vyp, vzp)
            call outpost(utmpx,utmpy,utmpz, prp, tp, 'cnv')
            
            ! subtract from output terms
            call opsub2(Lux,Luy,Luz,utmpx,utmpy,utmpz)

            call outpost(Lux,Luy,Luz, prp, tp, 'Ax_')
      

      ! compute divergence
            call opdiv(prp, Lux,Luy,Luz)
            
            call outpost(Lux,Luy,Luz, prp, tp, 'Ax_')

            print *, 'rnorm1 =', sqrt(glsc3(prp, bm2inv, prp, lp)/volvm2)
            print *, 'rnorm2 =', glsc2(prp, prp, lp)


            ! CG_ : compute_LNS with BC
            ! CGn : compute_LNS without BC
            ! CGo : opgradt with BC
            ! CGu : opgradt without BC
      
            call outpost(Lux,Luy,Luz, prp, tp, 'CGu')
            !call compute_LNS_gradp(Lux,Luy,Luz, prp)
            call opgradt(Lux,Luy,Luz, prp)
            !call bcdirvc(Lux,Luy,Luz, v1mask, v2mask, v3mask)
            call opdiv(prp,Lux,Luy,Luz)

            call outpost(Lux,Luy,Luz, prp, tp, 'CGu')
            
            !call compute_LNS_gradp(Lux,Luy,Luz, prp)
            call opgradt(Lux,Luy,Luz, prp)
            !call bcdirvc(Lux,Luy,Luz, v1mask, v2mask, v3mask)
            call opdiv(prp,Lux,Luy,Luz)
            
            call outpost(Lux,Luy,Luz, prp, tp, 'CGu')
            
            !call compute_LNS_gradp(Lux,Luy,Luz, prp)
            call opgradt(Lux,Luy,Luz, prp)
            !call bcdirvc(Lux,Luy,Luz, v1mask, v2mask, v3mask)
            call opdiv(prp,Lux,Luy,Luz)
            
            call outpost(Lux,Luy,Luz, prp, tp, 'CGu')
            
            !call compute_LNS_gradp(Lux,Luy,Luz, prp)
            call opgradt(Lux,Luy,Luz, prp)
            !call bcdirvc(Lux,Luy,Luz, v1mask, v2mask, v3mask)
            call opdiv(prp,Lux,Luy,Luz)
            
            call outpost(Lux,Luy,Luz, prp, tp, 'CGu')
            STOP 8
            DTD = DTD_linop()

            ! Copy from nek to nek_pdvector
            call nek2pr_vec(dpr, prp)
            call xCG%zero()
            ! Solve linear system D^T @ D x = dpr
            opts = cg_dp_opts(maxiter = 300, if_print_metadata = .true.)
            meta = cg_dp_metadata()
            call cg(DTD, dpr, xCG, info, rtol=rtol_dp, atol=atol_dp, options=opts, meta=meta)












            STOP 90










            
            ! LNS.
    		!A = LNS_linop(bf)
            !call A%init()
            
            
            ! 
            !call compare_nek_arnoldi(A, exptA, tau)

    		!call nek_end()
    	endif

      if (mod(istep,25) == 0 .or. istep == 1) call outpost(vxp,vyp,vzp,prp,tp,'prt')

      return
      end
c-----------------------------------------------------------------------
      subroutine userf (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0d0
      ffy = 0.0d0
      ffz = 0.0d0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         e  = gllel(ieg)
         ux=1.0d0
         uy=0.0d0
         uz=0.0d0
         temp=0.0d0
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e

      if (JP.eq.0) then         ! velocity
         ux = 1.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp=0.0d0
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
	include 'SIZE'
	include 'TOTAL'

        call setbc(5, 1, "W  ")
        call setbc(2, 1, "v  ")
        call setbc(3, 1, "v  ")
        call setbc(4, 1, "SYM")
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      return
      end

      subroutine Lu_op_conv(uxp,uyp,uzp,ipert)
         implicit none
   
         include 'SIZE'
         include 'INPUT'           ! if3d
         include 'SOLN'            ! v[xyz]
         !include 'OTD'             ! conv[xyz]
   
         ! argument list
         real uxp (lx1*ly1*lz1*lelv,1) ! perturbation velocity components
     $ ,   uyp (lx1*ly1*lz1*lelv,1)
     $ ,   uzp (lx1*ly1*lz1*lelv,1)
         integer ipert                 ! number of the considered pert.
   
         ! local variables
         integer ntot,i
         real TA1   (LX1,LY1,LZ1,LELV)
     $ ,   TA2   (LX1,LY1,LZ1,LELV)
     $ ,   TA3   (LX1,LY1,LZ1,LELV)
     $ ,   TB1   (LX1,LY1,LZ1,LELV)
     $ ,   TB2   (LX1,LY1,LZ1,LELV)
     $ ,   TB3   (LX1,LY1,LZ1,LELV)
   
         ! elements of the linearized operator (for debugging)
         real convx  (lx1*ly1*lz1*lelv,lpert)      ! convective term
     $ ,   convy  (lx1*ly1*lz1*lelv,lpert)
     $ ,   convz  (lx1*ly1*lz1*lelv,lpert)
     $ ,   gradpx (lx1*ly1*lz1*lelv,lpert)      ! pressure gradient term
     $ ,   gradpy (lx1*ly1*lz1*lelv,lpert)
     $ ,   gradpz (lx1*ly1*lz1*lelv,lpert)
     $ ,   diffx  (lx1*ly1*lz1*lelv,lpert)      ! diffusion term
     $ ,   diffy  (lx1*ly1*lz1*lelv,lpert)
     $ ,   diffz  (lx1*ly1*lz1*lelv,lpert)
   !
         common /OTD_Lup/ convx,convy,convz
     $ ,               gradpx,gradpy,gradpz
     $ ,               diffx,diffy,diffz
   !-----------------------------------------------------------------------
   
         ntot = lx1*ly1*lz1*lelv
   !
         if (if3d) then
           call opcopy  (tb1,tb2,tb3,vx,vy,vz)         ! Save velocity
           call opcopy  (vx,vy,vz,uxp,uyp,uzp)         ! U <-- u
   ! convop(conv,fld): builds the convective term for the scalar field fld
   !       conv_i = (v_j.grad_j)*fld_i                 => (vp_j.grad_j)*v_i
           call convop  (ta1,tb1)                      ! (u.grad) Ub
           call convop  (ta2,tb2)                                
           call convop  (ta3,tb3)
           ! Copy fields into the correct variables
           call opcopy  (convx(1,ipert),convy(1,ipert),convz(1,ipert)
     $ ,              ta1,ta2,ta3)
           call opcopy  (vx,vy,vz,tb1,tb2,tb3)         ! Restore velocity
   
   !       conv_i = (v_j.grad_j)*fld_i                 => (v_j.grad_j)*vp_i
           call convop  (tb1,uxp)                      ! (Ub.grad) u
           call convop  (tb2,uyp)
           call convop  (tb3,uzp)
           ! Add fields to the convective term
           call opadd2  (convx(1,ipert),convy(1,ipert),convz(1,ipert)
     $ ,              tb1,tb2,tb3)
   
   !   DIAGNOSTICS      
   !        call opcopy  (convx1(1,ipert),convy1(1,ipert),convz1(1,ipert)
   !     $ ,              ta1,ta2,ta3)
   !        call opcopy  (convx2(1,ipert),convy2(1,ipert),convz2(1,ipert)
   !     $ ,              tb1,tb2,tb3)
         else ! 2D
           call opcopy  (tb1,tb2,tb3,vx,vy,vz)         ! Save velocity
           call opcopy  (vx,vy,vz,uxp,uyp,uzp)         ! U <-- u
   ! convop(conv,fld): builds the convective term for the scalar field fld
   !       conv_i = (v_j.grad_j)*fld_i                 => (vp_j.grad_j)*v_i
           call convop  (ta1,tb1)                      ! (u.grad) Ub
           call convop  (ta2,tb2)                                
           ! Copy fields into the correct variables
           call opcopy  (convx(1,ipert),convy(1,ipert),ta3,ta1,ta2,ta3)
           call opcopy  (vx,vy,vz,tb1,tb2,tb3)         ! Restore velocity
   
   !       conv_i = (v_j.grad_j)*fld_i                 => (v_j.grad_j)*vp_i
           call convop  (tb1,uxp)                      ! (Ub.grad) u
           call convop  (tb2,uyp)
           ! Add fields to the convective term
           call opadd2  (convx(1,ipert),convy(1,ipert),tb3,tb1,tb2,tb3)
   !   DIAGNOSTICS      
   !        call opcopy  (convx1(1,ipert),convy1(1,ipert),ta3,ta1,ta2,ta3)
   !        call opcopy  (convx2(1,ipert),convy2(1,ipert),tb1,tb1,tb2,tb3)
         endif ! if3d
   
         return
         end subroutine Lu_op_conv
   
   !======================================================================
   !> @brief Construct the pressure gradient term for Lu
   !
   !     Lu_gradp = grad p
   !
   !     Note: The pressure gradient is computed directly on the v-mesh!
   !
         subroutine Lu_op_gradp(prpert,ipert)
         implicit none
   
         include 'SIZE'
         !include 'OTD'             ! gradp[xyz]
   
         ! argument list
         real prpert (lx2*ly2*lz2*lelv,1) ! perturbation pressure field
         integer ipert                    ! number of the considered pert.
   
         ! local variables
         integer ntot
         real ta1 (lx1,ly1,lz1,lelv)  
     $ ,   ta2 (lx1,ly1,lz1,lelv)  
     $ ,   wrk (lx1,ly1,lz1,lelv)  
   
         ! elements of the linearized operator (for debugging)
         real convx  (lx1*ly1*lz1*lelv,lpert)      ! convective term
     $ ,   convy  (lx1*ly1*lz1*lelv,lpert)
     $ ,   convz  (lx1*ly1*lz1*lelv,lpert)
     $ ,   gradpx (lx1*ly1*lz1*lelv,lpert)      ! pressure gradient term
     $ ,   gradpy (lx1*ly1*lz1*lelv,lpert)
     $ ,   gradpz (lx1*ly1*lz1*lelv,lpert)
     $ ,   diffx  (lx1*ly1*lz1*lelv,lpert)      ! diffusion term
     $ ,   diffy  (lx1*ly1*lz1*lelv,lpert)
     $ ,   diffz  (lx1*ly1*lz1*lelv,lpert)
   !
         common /OTD_Lup/ convx,convy,convz
     $ ,               gradpx,gradpy,gradpz
     $ ,               diffx,diffy,diffz
   !-----------------------------------------------------------------------
   
         ntot = lx2*ly2*lz2*lelv
   !     Map the perturbation pressure to the velocity mesh
         call mappr(wrk,prpert,ta1,ta2)
   !     compute the gradient on the velocity mesh direclty
         call gradm1(gradpx(1,ipert),gradpy(1,ipert),gradpz(1,ipert),wrk)
   
         return
         end subroutine Lu_op_gradp
   
   !======================================================================
   !> @brief Construct the diffusive term for Lu
   !
   !     Lu_op_diff = 1/Re*grad^2 u
   !
         subroutine Lu_op_diff(uxp,uyp,uzp,ipert)
         implicit none
   
         include 'SIZE'
         include 'INPUT'           ! if3d
         include 'SOLN'            ! vdiff
         !include 'OTD'             ! diff[xyz]
   
         ! argument list
         real uxp (lx1*ly1*lz1*lelv,1) ! perturbation velocity components
     $ ,   uyp (lx1*ly1*lz1*lelv,1)
     $ ,   uzp (lx1*ly1*lz1*lelv,1)
         integer ipert                 ! number of the considered pert.
         ! local variables
         integer ntot
   
         ! elements of the linearized operator (for debugging)
         real convx  (lx1*ly1*lz1*lelv,lpert)      ! convective term
     $ ,   convy  (lx1*ly1*lz1*lelv,lpert)
     $ ,   convz  (lx1*ly1*lz1*lelv,lpert)
     $ ,   gradpx (lx1*ly1*lz1*lelv,lpert)      ! pressure gradient term
     $ ,   gradpy (lx1*ly1*lz1*lelv,lpert)
     $ ,   gradpz (lx1*ly1*lz1*lelv,lpert)
     $ ,   diffx  (lx1*ly1*lz1*lelv,lpert)      ! diffusion term
     $ ,   diffy  (lx1*ly1*lz1*lelv,lpert)
     $ ,   diffz  (lx1*ly1*lz1*lelv,lpert)
   !
         common /OTD_Lup/ convx,convy,convz
     $ ,               gradpx,gradpy,gradpz
     $ ,               diffx,diffy,diffz
   !-----------------------------------------------------------------------
   
         ntot = lx1*ly1*lz1*lelv
         ! compute laplacian
         call laplacian(diffx(1,ipert),uxp)
         call laplacian(diffy(1,ipert),uyp)
         if (if3d) call laplacian(diffz(1,ipert),uzp) 
         ! multiply by 1/Re                > remove for operator diagnostics
         call col2(diffx(1,ipert),vdiff,ntot) 
         call col2(diffy(1,ipert),vdiff,ntot) 
         if (if3d) call col2(diffz(1,ipert),vdiff,ntot) 
   
         return
         end subroutine Lu_op_diff
   
   !======================================================================
   !> @brief Construct the diffusion term (laplacian of u) for direction i
   !
         subroutine laplacian(lapu,up)
         implicit none
   !
         include 'SIZE'
         include 'INPUT'           ! if3d
         include 'DXYZ'            ! dxm1,d[xy]tm1
         include 'GEOM'            ! r[xy]m1,s[xy]m1,t[xy]m1,jacmi
   !
         ! argument list
         real up (lx1*ly1*lz1*lelv,1)       ! perturbation velocity component
   !
         ! output
         real lapu (lx1*ly1*lz1,lelv)
   !
         ! local variables
         real ux  (lx1*ly1*lz1,lelv)
     $ ,   uy  (lx1*ly1*lz1,lelv)
     $ ,   uz  (lx1*ly1*lz1,lelv)
     $ ,   ur  (lx1*ly1*lz1)
     $ ,   us  (lx1*ly1*lz1)
     $ ,   ut  (lx1*ly1*lz1)
   !
         common /ctmp1/ ur,us,ut
   !
         integer e,i,lxyz,nel,N
   !-----------------------------------------------------------------------
   
         lxyz = lx1*ly1*lz1
         nel = nx1-1
         call gradm1(ux,uy,uz,up)
         do e=1,lelt
           if (if3d) then
             call local_grad3(ur,us,ut,ux,nel,e,dxm1,dxtm1)
             do i=1,lxyz
               lapu(i,e) = jacmi(i,e)*(  ur(i)*rxm1(i,1,1,e)
     $                              + us(i)*sxm1(i,1,1,e)
     $                              + ut(i)*txm1(i,1,1,e) )
             enddo
             call local_grad3(ur,us,ut,uy,nel,e,dxm1,dxtm1)
             do i=1,lxyz
               lapu(i,e) = lapu(i,e) + jacmi(i,e)*(  ur(i)*rym1(i,1,1,e)
     $                                          + us(i)*sym1(i,1,1,e)
     $                                          + ut(i)*tym1(i,1,1,e) )
             enddo
             call local_grad3(ur,us,ut,uz,nel,e,dxm1,dxtm1)
             do i=1,lxyz   
               lapu(i,e) = lapu(i,e) + jacmi(i,e)*(  ur(i)*rzm1(i,1,1,e)
     $                                          + us(i)*szm1(i,1,1,e)
     $                                          + ut(i)*tzm1(i,1,1,e) )
             enddo
           else ! 2D
             call local_grad2(ur,us,ux,nel,e,dxm1,dytm1)
             do i=1,lxyz
               lapu(i,e) = jacmi(i,e)*(ur(i)*rxm1(i,1,1,e)
     $                            + us(i)*sxm1(i,1,1,e) )
             enddo
             call local_grad2(ur,us,uy,nel,e,dxm1,dytm1)
             do i=1,lxyz
               lapu(i,e) = lapu(i,e)
     $                  + jacmi(i,e)*(ur(i)*rym1(i,1,1,e)
     $                              + us(i)*sym1(i,1,1,e) )
             enddo
           endif ! if3d
         enddo
   !      
         return
         end subroutine laplacian